음...
일단 새로운 유저에 대해서 추천을 해줄 때, 
새로운 유저를 제외하고 학습된, 기존 학습 모델을 통해서는 좋은 추천이 될 수 없고, 할 수도 없다.
따라서, 새로운 유저를 포함하고 재학습을 시킨다음에 그 사람을 추천해주는 것이 베스트이다.

그러기 위해서 어떤 식의 플로우여야할까..

1. 새로운 유저가 들어온다. 그 유저의 고유 번호를 어떻게 받지? 
-> 받는게 아니야. 요청이 들어오면, 내가 스스로 그 유저의 고유 번호를 만든 다음에
   그 유저 벡터를 넣고 재학습 시키고, 그 유저의 추천 값만 쏙 가져올 수 있도록 해야한다.

   그러려면, txt파일에 데이터가 있으니까.. 
   - 그 txt파일에 새로운 유저의 선호 레시피를 넣는 것 구현.
   - 갱신된 txt파일을 토대로 학습.
   - 학습 후, 10개의 추천을 뽑는 함수 사용해서 출력. (출력을 어차피 함수로 하면 돼)

   
   데이터 프레임에 추가하는 학습의 에폭이 너무 크면 오래 걸리니까.. 
   한 20~30정도에서 끝내자. 너무 학습시키면 과적합나더라.
   -> 6으로 결정.


문제가 발생했는데.. 인코딩이 잘 안되고 있네.. 보니까..
미리 학습된 것들을 다시 끌고와서 합쳐서 fit하고... 


만들 API

1. 유저의 고유 번호와 선호 리스트를 입력받아 txt파일에 저장. -> 반환값이 따로 필요없음. 그냥 저장만 해주면 됨.
   -> 이미 존재하는 유저는 선호 리스트를 갱신함.

2. 학습 시키는 함수.

3. 유저의 고유번호를 입력하면 그 유저의 추천 결과를 뱉는 함수.


수정해야할 파일:
ini 파일에 train, test 파일 경로.
main 파일에 여러 파일들 경로.

백엔드 입장에서는, 그냥 그 유저의 이름(백엔드에서의 고유 번호겠지)과 그 유저의 선호 리스트를 보내면 그냥 바로 학습이 이루어지고,
찾을때는 백엔드에서의 고유 번호 넣으면 바로 추천 결과나오도록 하면 된다.


데이터가 저장된 txt파일의 user정보가 변경되면, 그 변경된 것을 대상으로 다시 user_label_matrix를 만들어 줘야한다.

해야할 일
Recipeid_LE에 없는 레시피는 무시하는 코드 넣어야한다.
유저가 존재하는 상황에서 10개 이상일 경우, test를 다시 채워넣는 방법을 생각해보자. (그 사이를 어떻게 기억하지?)