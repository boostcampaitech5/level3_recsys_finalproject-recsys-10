음...
우선 레시피 아이디를 마지막에 10개 출력해줘야하는 거고.
cook은 굳이 안써도 될거같아.
중요한 건, view랑 level, 재료 정보가 되겠지.

만약 유저가 새송이 버섯, 버터, 간장, 맛술 이렇게 있다고 치면,

1. 필터링 방식: 새송이 버섯 없는 것 제거. 버터 제거. 간장 제거. 맛술 제거. 이렇게 해서 남아진 것들이 있을텐데, 이것들에 대해, 난이도로도 필터링하고 남은 것은 조회수로 정렬하여 추천. 
                만약 없다면? -> 어떤 재료를 없앤 것 중에서 추천할지가 고민이 됨. 
                또한, 재료가 넘칠수도 있음.


2. 컨텐츠 베이스 추천 시스템: 

1. 재료들을 가중치가 존재하는 희소 벡터로 표현한다.  [0,0.7 0 0 0.3...]  재료 1 난이도  -> 후추 고추가루 (가중치 조금.) 새송이 볶음 새송이 (가중치 높게.) 
이 때, 가중치를 주는 방법은 빈도수 (선우가 한 그 EDA 데이터) 를 통해서 가중치를 준다.

2. 희소 벡터를 밀집 벡터로 표현한다. (차원의 저주 막기) [0.12, 0.34,...] 64 + 요리난이도, 카테고리(원 핫 인코딩)

3. 재료 밀집 벡터와 카테고리, 요리 난이도, 시간을 희소 벡터로 표현하여 둘을 합치고 유사도를 측정 -> 유사도는 일단 코사인 유사도, 다른 것도 사용해보자.

4. 상위 30개를 뽑아내고 그 30개 중 조회수 순으로 다시 정렬하여 추천. 10개 


5. 사용자의 냉장고에서 이름을 입력하면, 그 이름이 들어간 재료들의 리스트를 뽑는다 -> 예를 들어, 오징어라고 입력이 오면, 작은 오징어, 썬 오징어, 이런 재료(레시피 안에 있는 이름의 재료)
   들을 모으고, 이 중에 가장 빈도수가 큰 것을 기준으로 재료 벡터에 가중치를 부여한다. 
   (다 줘버리면 작은 오징어나, 썬 오징어 같은 유니크한 레시피만 나올 듯. -> 실제로 작은 오징어라는 재료가 들어간 레시피는 단 1개임.) 

   대신, 사용자에게 당부: 포괄하는 음식 이름을 입력해주세요. ex) 미니 돈까스, 고구마치즈돈까스 -> 돈까스,  느타리버섯 팩 -> 느타리버섯

6. 위의 것이 어려울 것 같으면... 레시피들을 보여주고, 지금 만들 수 있을 것 같은 음식의 레시피를 고르시면, 이렇게 추천도 됨


#
1차: 재료 밀집벡터만 사용. -> 정확도 나쁘지 않음.

해야할 것: 요리난이도, 카테고리, 시간 등등을 희소벡터로 표현하여 벡터 합치고 결과 보기.
          사용자한테 입력받는 부분도 구현해놓기. -> fit함수를 사용하여 미리 해놓고, transform함수로 사용자 입력부분만 사용.

#
그리고... 재료에 가중치 어떻게 더 잘 줄지 고민좀 해 봐
-> 만약 제목이나, 음식 제목에 그 재료의 이름이 통째로 들어가면... 가중치를 크게 늘리는 방식으로 해볼까?
-> 했더니 엄청나게 큰 성공이야. 주요재료는 다 들어가게 됐어. 근데 문제는. 같은 메뉴만 계속 나와. 예를들어, 김치, 돼지고기, 두부를 넣으면 돼지고기김치찌개만 한 8개 나오는 느낌이야.

-> 이걸 처리하기 위해, 같은 cook이면 최대 2개까지만 나오게 해볼까? 조회수 순으로 정렬해서말이야.
-> 또는, 주 재료(cook에 등장한 재료)들의 가중치만 높인 유저 벡터를 많이 만들어서 주재료별로 몇개씩만 뽑아도 종류가 많게 나오지 않을까?...

이 두가지 중에 고민해서 하나 해보자. 

지금 유저의 주 재료는 가중치가 크게 들어가지 않아. 이거는 좀 더 고민해보자.

#
데이터 정제만 가능하면, 재료기반 추천시스템은 더 좋은 모델이 될 수 있다 -> 재료 겹치는 것들만 라벨링해서 처리해주면됨 
-> 돼지 고기와 돼지고기를 다르게 봄 ㅠㅠ... 계란과 달걀도 다르게보고. 이런거만 통일시켜주면 베스트다.

데이터프레임만 바꿔주면 알아서 벡터만들도록 코드는 구현해놨으니, 데이터프레임의 ingredients만 해결해주면된다. -> 계란과 달걀에서 계란으로 통일시키는 등의 수작업.

이 모델이 굴러가는 시간이 너무 오래걸려... 이러면 음 numpy를 사용해서 gpu를 사용해서 시간을 단축시켜볼까?



